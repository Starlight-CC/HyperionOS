local args=({...})[1]
local fs=require("filesystem")
--local sfs=fs.getSudo(args.masterKey)
local auth=require("auth")
local hypervisor={}
local thread={}
local processes={}
local events={}
local UUID_VAL=-1
local time=0
local term=component.getFirst("screen")
local function UUID()
    UUID_VAL=UUID_VAL+1
    return UUID_VAL
end
-- Stuff related to current process
local currentPCB={
    exe="/boot/Hyprkrnl.sys",
    name="Hyprkrnl"
}

local currentThread={}

args.pname(function()
    return currentPCB.name
end)

function hypervisor.addEvent(event, func)
    if not events[currentPCB.UUID] then
        events[currentPCB.UUID]={}
    end
    if not events[currentPCB.UUID][event] then
        events[currentPCB.UUID][event]={}
    end
    events[currentPCB.UUID][event][#events[currentPCB.UUID][event]+1] = func
end

function hypervisor.triggerEvent(target, event, ...)
    local args={...}
    if events[target] then
        if events[target][event] then
            for i,v in pairs(events[target][event]) do
                if processes[v.parent] then
                    processes[v.parent].threads["EVH_"..i]=coroutine.create(function()
                        pcall(v.func, event, table.unpack(args))
                    end)
                else
                    events[target][event][i]=nil
                end
            end
        end
    else
        if target=="all" then
            for _, t in pairs(events) do
                if t[event] then
                    for i,v in pairs(events[target][event]) do
                        if processes[v.parent] then
                            processes[v.parent].threads["EVH_"..i]=coroutine.create(function()
                                pcall(v.func, event, table.unpack(args))
                            end)
                        else
                            events[target][event][i]=nil
                        end
                    end
                end
            end
        end
    end
end

local function createTCB(func, args, parent, ret, name)
    return {
        thread=coroutine.create(function()
            local ok, err = pcall(func, table.unpack(args))
            if not ok then
                ret=nil
                hypervisor.triggerEvent(parent, "threadError", name, err)
            else
                ret=nil
                hypervisor.triggerEvent(parent, "threadReturn", name, err)
            end
        end),
        status="new",
        sleep=0
    }
end

function thread.create(func, name, ...)
    local args={...}
    local parent=currentPCB.UUID

    if currentPCB.threads[name] then error("thread "..name.." already exists") end
    local ret = {}
    currentPCB.threads[name]=createTCB(func, args, parent, ret, name)
    function ret.kill()
        ret = nil
        processes[parent].threads[name].status="exit"
        hypervisor.triggerEvent(parent, "threadKilled", name)
    end
    function ret.pause()
        processes[parent].threads[name].status="paused"
    end
    function ret.resume()
        if processes[parent].threads[name].status=="paused" then
            processes[parent].threads[name].status="normal"
        end
    end
    function ret.status()
        return processes[parent].threads[name].status
    end
    return ret
end

function thread.exit()
    currentThread.status="exit"
end

function thread.sleep(wtime)
    local ntime=time+wtime
    currentThread.sleep=ntime
    currentThread.status="sleeping"
    coroutine.yield()
end
local oldSleep=sleep
sleep=thread.sleep

function hypervisor.createProcessFromFunc(func, name, ...)
    local id = tostring(UUID())
    local args={...}
    local ret={}
    processes[id]={
        threads={
            main=createTCB(func, args, id, ret, "main")
        },
        status="new",
        Iyeid=0,
        Vyeild=0,
        UUID=id,
        name=name
    }
    function ret.kill()
        processes[id].status="exit"
    end
    function ret.pause()
        processes[id].status="paused"
    end
    function ret.resume()
        if processes[id].status=="paused" then
            processes[id].status="normal"
        end
    end
    function ret.getID()
        return id
    end
    return ret
end

function hypervisor.isrunning(pid)
    if processes[tostring(pid)] then
        return true
    else
        return false
    end
end

function hypervisor.createProcessFromFile(path, name, ...)
    local file = fs.open(path, "x")
    local ret = hypervisor.createProcessFromFunc(file, name, ...)
    processes[ret.getID()].exe=path
    return ret
end

local function pruneDeadEvents()
    for i,v in pairs(events) do
        if not processes[i] then
            events[i]=nil
        end
    end
end

args.setRequire("hypervisor", hypervisor)
args.setRequire("thread", thread)

local function main(func)
    hypervisor.createProcessFromFunc(func, "Hyprkrnl")
    while true do
        for i,v in pairs(processes) do
            currentPCB=v
            if currentPCB==nil then
            elseif currentPCB.status == "paused" then
            elseif currentPCB.status=="exit" then
                currentPCB=nil
            else
                for i2,v2 in pairs(currentPCB.threads) do
                    currentThread=v2
                    if currentThread==nil then
                    elseif currentThread.status=="paused" then
                    elseif currentThread.status=="sleeping" then
                        if time>=currentThread.sleep then
                            currentThread.status="normal"
                        end
                    elseif currentThread.status=="exit" then
                        currentThread=nil
                    else
                        local timeout = coroutine.resumeWithTimeout(currentThread.thread, 0.02)
                        if currentThread.status=="new" then
                            currentThread.status="normal"
                        end
                        if timeout then
                            currentPCB.Iyeid=currentPCB.Iyeid+1
                        else
                            currentPCB.Vyeild=currentPCB.Vyeild+1
                        end
                        if i2=="main" then
                            if currentThread.status=="exit" or coroutine.status(currentThread.thread)=="dead" then
                                currentPCB.status="exit"
                                pruneDeadEvents()
                                hypervisor.triggerEvent("all", "processExit", i)
                            end
                        else
                            if currentThread.status=="exit" or coroutine.status(currentThread.thread)=="dead" then
                                currentThread.status="exit"
                            end
                        end
                    end
                    if currentPCB~=nil then
                        currentPCB.threads[i2]=currentThread
                    end
                end
                if currentPCB~=nil then
                    if currentPCB.status=="new" then
                        currentPCB.status="normal"
                    end
                end
            end
            processes[i]=currentPCB
        end
        oldSleep(0.02)
        time=time+0.02
    end
end

return main