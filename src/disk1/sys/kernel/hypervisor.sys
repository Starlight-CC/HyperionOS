local args=({...})[1]
local fs=require("filesystem")
--local sfs=fs.getSudo(args.masterKey)
local auth=require("auth")
local hypervisor={}
local thread={}
local processes={}
local events={}
local UUID_VAL=-1
local time=0
local function UUID()
    UUID_VAL=UUID_VAL+1
    return UUID_VAL
end
-- Stuff related to current process
local currentPCB={
    exe="/boot/Hyprkrnl.sys"
}

local currentThread={}

function hypervisor.triggerEvent(target, event, ...)
    local args={...}
    if events[target] then
        if events[target][event] then
            for i,v in pairs(events[target][event]) do
                if processes[v.parent] then
                    processes[v.parent].threads["EVH_"..i]=coroutine.create(function()
                        pcall(v.func, event, table.unpack(args))
                    end)
                else
                    events[target][event][i]=nil
                end
            end
        end
    else
        if target=="all" then
            for _, t in pairs(events) do
                if t[event] then
                    for i,v in pairs(events[target][event]) do
                        if processes[v.parent] then
                            processes[v.parent].threads["EVH_"..i]=coroutine.create(function()
                                pcall(v.func, event, table.unpack(args))
                            end)
                        else
                            events[target][event][i]=nil
                        end
                    end
                end
            end
        end
    end
end

local function createTCB(func, args, parent, ret, name)
    return {
        thread=coroutine.create(function()
            local ok, err = pcall(func, table.unpack(args))
            if not ok then
                ret=nil
                hypervisor.triggerEvent(parent, "threadError", name, err)
            else
                ret=nil
                hypervisor.triggerEvent(parent, "threadReturn", name, err)
            end
        end),
        status="new",
        sleep=0
    }
end

function thread.create(func, name, ...)
    local args={...}
    local parent=currentPCB.UUID

    if currentPCB.threads[name] then error("thread "..name.." already exists") end
    local ret = {}
    currentPCB.threads[name]=createTCB(func, args, parent, ret, name)
    function ret.kill()
        ret = nil
        processes[parent].threads[name]=nil
        hypervisor.triggerEvent(parent, "threadKilled", name)
    end
    function ret.pause()
        processes[parent].threads[name].status="paused"
    end
    function ret.resume()
        if processes[parent].threads[name].status=="paused" then
            processes[parent].threads[name].status="normal"
        end
    end
    function ret.status()
        return processes[parent].threads[name].status
    end
    return ret
end

function thread.exit()
    currentThread=nil
end

function thread.sleep(wtime)
    local ntime=time+wtime
    currentThread.sleep=ntime
    currentThread.status="sleeping"
end
local oldSleep=sleep
_G.sleep=thread.sleep

function hypervisor.createProcessFromFunc(func, name, ...)
    local id = tostring(UUID())
    local args={...}
    local ret={}
    processes[id]={
        threads={
            main=createTCB(func, args, id, ret, "main")
        },
        status="new",
        sleep=0
    }
    function ret.kill()
        processes[id]=nil
    end
    function ret.pause()
        processes[id].status="paused"
    end
    function ret.resume()
        if processes[id].status=="paused" then
            processes[id].status="normal"
        end
    end
end

args.setRequire("hypervisor", hypervisor)
args.setRequire("thread", thread)

local function main(func)
    hypervisor.createProcessFromFunc(func, name)
    while true do
        for i,v in pairs(processes) do
            currentPCB=v
            for i2,v2 in pairs(currentPCB.threads) do
                currentThread=v2
                coroutine.resume(currentThread.thread)
                if i2=="main" then
                    if currentThread==nil or coroutine.status(currentThread.thread)=="dead" then
                        currentPCB=nil
                        hypervisor.triggerEvent("all", "processExit", i)
                    end
                else
                    if currentThread==nil or coroutine.status(currentThread.thread)=="dead" then
                        currentThread=nil
                    end
                end
                if currentPCB then
                    currentPCB.threads[i2]=currentThread
                end
            end
            processes[i]=currentPCB
        end
        oldSleep(0.02)
        time=time+0.02
    end
end

return main