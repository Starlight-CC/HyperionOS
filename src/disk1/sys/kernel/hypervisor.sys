local args=({...})[1]
local fs=require("filesystem")
--local sfs=fs.getSudo(args.masterKey)
local auth=require("auth")
local hypervisor={}
local thread={}
local processes={}
local events={}
local UUID_VAL=-1
local euuid=-1
local time=0
local term=component.getFirst("screen")
local function UUID()
    UUID_VAL=UUID_VAL+1
    return UUID_VAL
end
-- Stuff related to current process
local currentPCB={
    exe="/boot/Hyprkrnl.sys",
    name="Hyprkrnl"
}

local currentThread={}

args.pname(function()
    return currentPCB.name
end)

local function addEvent(event, func, id)
    if not events[id] then
        events[id]={}
    end
    if not events[id][event] then
        events[id][event]={}
    end
    local ret={}
    euuid=euuid+1
    local eid=tostring(euuid)
    local parent=id
    events[id][event][eid] = func
    function ret.close()
        events[parent][event][eid]=nil
        ret=nil
    end
    return ret
end

function hypervisor.addEvent(event, func)
    return addEvent(event, func, currentPCB.UUID)
end

local function createTCB(func, args, parent, ret, name)
    return {
        thread=coroutine.create(function()
            local ok, err = pcall(func, table.unpack(args))
            if not ok then
                ret=nil
                hypervisor.triggerEvent(parent, "threadError", parent, name, err)
            else
                ret=nil
                hypervisor.triggerEvent(parent, "threadReturn", parent, name, err)
            end
        end),
        status="new",
        sleep=0,
        handle=ret,
        name=name
    }
end

function hypervisor.triggerEvent(target, event, ...)
    local args={...}
    if events[target] then
        if events[target][event] then
            for i,v in pairs(events[target][event]) do
                if processes[target] then
                    processes[target].threads["EVH_"..i]=createTCB(v, args, target, nil, "EVH_"..i)
                else
                    events[target]=nil
                end
            end
        end
        if events[target]["all"] then
            for i,v in pairs(events[target]["all"]) do
                if processes[target] then
                    processes[target].threads["EVH_"..i]=createTCB(v, {event, table.unpack(args)}, target, nil, "EVH_"..i)
                else
                    events[target]=nil
                end
            end
        end
    else
        if target=="all" then
            for p, t in pairs(events) do
                if t[event] then
                    for i,v in pairs(t[event]) do
                        if processes[p] then
                            processes[p].threads["EVH_"..i]=createTCB(v, args, p, nil, "EVH_"..i)
                        else
                            events[p]=nil
                        end
                    end
                end
                if t["all"] then
                    for i,v in pairs(t[event]) do
                        if processes[p] then
                            processes[p].threads["EVH_"..i]=createTCB(v, {event, table.unpack(args)}, p, nil, "EVH_"..i)
                        else
                            events[p]=nil
                        end
                    end
                end
            end
        end
    end
end

local function createThread(id, func, name, ...)
    local args={...}
    if not name then error("name must be supplied") end
    local parent=id

    if processes[id].threads[name] then error("thread "..name.." already exists") end
    local ret = {}
    processes[id].threads[name]=createTCB(func, args, parent, ret, name)
    function ret.kill()
        ret = nil
        processes[parent].threads[name].status="exit"
        hypervisor.triggerEvent(parent, "threadKilled", name)
    end
    function ret.pause()
        processes[parent].threads[name].status="paused"
    end
    function ret.resume()
        if processes[parent].threads[name].status=="paused" then
            processes[parent].threads[name].status="normal"
        end
    end
    function ret.status()
        return processes[parent].threads[name].status
    end
    return ret
end

function thread.create(func, name, ...)
    createThread(currentPCB.UUID, func, name, ...)
end

function thread.exit()
    currentThread.status="exit"
end

function thread.sleep(wtime)
    local ntime=time+wtime
    currentThread.sleep=ntime
    currentThread.status="sleeping"
    coroutine.yield()
end

local oldSleep=sleep
sleep=thread.sleep

function hypervisor.createProcessFromFunc(func, name, ...)
    local id = tostring(UUID())
    if not name then error("name must be supplied") end
    local args={...}
    local ret={}
    processes[id]={
        threads={
            main=createTCB(func, args, id, ret, "main")
        },
        status="new",
        Iyeild=0,
        Vyeild=0,
        UUID=id,
        name=name,
        handle=ret
    }
    function ret.kill()
        processes[id].status="exit"
    end
    function ret.pause()
        processes[id].status="paused"
    end
    function ret.resume()
        if processes[id].status=="paused" then
            processes[id].status="normal"
        end
    end
    function ret.getID()
        return id
    end
    return ret
end

function hypervisor.isrunning(pid)
    if table.hasKey(processes, pid) then
        return true
    else
        return false
    end
end

function hypervisor.createProcessFromFile(path, name, ...)
    local file = fs.open(path, "x")
    local ret = hypervisor.createProcessFromFunc(file, name, ...)
    processes[ret.getID()].exe=path
    return ret
end

function hypervisor.attachDebugger(handle)
    local pid=handle.getID()
    if processes[pid] then
        if handle==processes[pid].handle then
            hypervisor.triggerEvent(pid, "attachDebugger", currentPCB.UUID, currentThread.name)
            local ret = {
                addEvent=function(event, func)
                    return addEvent(event, func, pid)
                end,
                makeThread=function(func, name, ...)
                    return createThread(pid, func, name, ...)
                end
            }
            return ret
        end
    end
    return "Invailid handle"
end

local function pruneDeadEvents()
    for i,v in pairs(events) do
        if not processes[i] then
            events[i]=nil
        end
    end
end

args.setRequire("hypervisor", hypervisor)
args.setRequire("thread", thread)
local print=component.getFirst("screen").print
local function funct(tble,space)
    space=space or ""
    for i,v in pairs(tble) do
        print(space..tostring(i).." | "..tostring(v))
        if type(v) == "table" then
            if i=="_G" then else
                funct(v,space.."   ")
            end
        end
    end
end
local function main(func)
    hypervisor.createProcessFromFunc(func, "Hyprkrnl")
    while true do
        for i,v in pairs(processes) do
            currentPCB=v
            if currentPCB==nil then
            elseif currentPCB.status == "paused" then
            elseif currentPCB.status=="exit" then
                currentPCB=nil
            else
                for i2,v2 in pairs(currentPCB.threads) do
                    currentThread=v2
                    if currentThread==nil then
                    elseif currentThread.status=="paused" then
                    elseif currentThread.status=="sleeping" then
                        if time>=currentThread.sleep then
                            currentThread.status="normal"
                        end
                    elseif currentThread.status=="exit" then
                        currentThread=nil
                    else
                        local timeout = coroutine.resumeWithTimeout(currentThread.thread, 0.02)
                        --funct(processes)
                        if currentThread.status=="new" then
                            currentThread.status="normal"
                        end
                        if timeout then
                            currentPCB.Iyeild=currentPCB.Iyeild+1
                        else
                            currentPCB.Vyeild=currentPCB.Vyeild+1
                        end
                        if i2=="main" then
                            if currentThread.status=="exit" or coroutine.status(currentThread.thread)=="dead" then
                                --funct(processes)
                                currentPCB.status="exit"
                                pruneDeadEvents()
                                hypervisor.triggerEvent("all", "processExit", i, currentPCB.name)
                            end
                        else
                            if currentThread.status=="exit" or coroutine.status(currentThread.thread)=="dead" then
                                --funct(processes)
                                currentThread.status="exit"
                            end
                        end
                    end
                    if currentPCB~=nil then
                        currentPCB.threads[i2]=currentThread
                    end
                end
                if currentPCB~=nil then
                    if currentPCB.status=="new" then
                        currentPCB.status="normal"
                    end
                end
            end
            processes[i]=currentPCB
        end
        oldSleep(0.02)
        time=time+0.02
    end
end

return main